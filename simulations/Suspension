#ARCHITECTURE OVERVIEW:
#1. DONE: Import two data files: Rover info and soil info
#   -100% complete:
#       *DONE:implement soil ini file
#2. Compute traction information from solid case
#   -99% complete:
#       *DONE: compute maximum thrust function
#       *DONE: compute compaction resistance function
#       *DONE? : compute bulldozing resistance function
#       *DONE: compute rolling resistance (use coeff of 0 if negligable) function
#       *DONE: compute gravitational resistance function
#       *DONE: create aggregate drawbar pull function
#3. Create angle geometry calculator for pivot and 4 bar cases
#   -100% complete:
#       *DONE: differentiate from obstacle mode and slope mode
#       *DONE: from rover geometry and height, get alpha and beta
#4. Create matrix calculator
#   -5% comlete:
#       *function to generate computation matrix for each scenario:
#           1. rover climbing obstacle of height h lower than radius
#           2. DONE: rover climbing obstacle of height h higher than radius
#           3. rover going across a slope
#           4. rover driving straight
#5. create simulation
#   -0% complete:
#       *Calculate drawbar pull for each case mentioned previously
#       *calculate max velocity, acceleration and gradeability
#       *calculate required torque for stall conditions (adhesion based)
#       *calculate stability
#6. create simulation to optimize rover parameters
#   -0% complete:
#       *given rover parameter and acceptable ranges, run through all instances and find ideal case for each performance parameters
#7. optimize four bar rover
#   -0% complete:
#   -Based on previous ideal parameters, using all variable 4 bar variables, find ideal case for each performance parameters
###IMPORT LIBRARIES###
from scipy.optimize import fsolve
import math
import numpy as np
import configparser
###CONSTANTS SETUP###
g = 9.80655
###ROVER CLASS SETUP###
class rover:
    def __init__(self, roverconfiguration, four_bar, solid_wheel = True):
        self.wheel_mass = float(roverconfiguration['Weight Values (in kg)']['wheel_mass'])
        self.bogie_mass = float(roverconfiguration['Weight Values (in kg)']['bogie_mass'])
        self.wheel_link_mass = float(roverconfiguration['Weight Values (in kg)']['wheel_link_mass'])
        self.bogie_total_mass = self.bogie_mass + 2*self.wheel_link_mass
        self.body_mass = float(roverconfiguration['Weight Values (in kg)']['body_mass'])
        self.total_mass = self.wheel_mass + self.bogie_total_mass + self.body_mass
        self.coefficient_of_friction = float(roverconfiguration['Weight Values (in kg)']['coefficient_of_friction'])
        self.bogie_length = float(roverconfiguration['Lengths (in m)']['bogie_length'])
        self.wheel_link_length = float(roverconfiguration['Lengths (in m)']['wheel_link_length'])
        self.wheel_radius = float(roverconfiguration['Lengths (in m)']['wheel_radius'])
        self.wheel_width = float(roverconfiguration['Lengths (in m)']['wheel_width'])
        self.body_cg_length = float(roverconfiguration['CG']['body_cg_length'])
        self.cg_length = float(roverconfiguration['Lengths (in m)']['cg_length'])
        self.cg_height = float(roverconfiguration['Lengths (in m)']['cg_height'])
        self.poisson = float(roverconfiguration['Material']['poisson'])
        self.youngs_modulus = float(roverconfiguration['Material']['youngs_modulus'])
        self.four_bar = four_bar
        self.solid_wheel = solid_wheel
        self.slope_matrix = np.zeros((15,15))
        self.low_obs_matrix = np.zeros((15,15))
        self.high_obs_matrix = np.zeros((15,15))
        self.b_slope = np.zeros(15)
        self.b_low_obs = np.zeros(15)
        self.b_high_obs = np.zeros(15)
    def compute_cg(rover):
        cg_length = (rover.body_mass*rover.body_cg_length + 1.5*rover.bogie_length * 2*(rover.bogie_total_mass + 2*rover.wheel_mass)) \
        / (rover.body_mass + 2*rover.bogie_total_mass + 6*rover.wheel_mass)
        cg_height = (6*rover.wheel_radius + \
        2* (2*rover.wheel_link_length*(0.5*rover.wheel_link_length + rover.wheel_radius) + rover.bogie_mass*(rover.wheel_radius+rover.wheel_link_length+rover.bogie_tube_height/2)) + \
        )
        return 1
        #computes centre of gravity based on cg of components
        #assumption: wheel CG at center, bogie symmetric
    def A_set(self, matrix, r, c, value):
        if(matrix is 0):
            self.slope_matrix[r][c] = value
        if(matrix is 1):
            self.low_obs_matrix[r][c] = value
        if(matrix is 2):
            self.high_obs_matrix[r][c] = value
        else:
            print("A MATRIX SET ERROR")
    def b_set(self, matrix, r, value):
        if(matrix is 0):
            self.b_slope[r] = value
        if(matrix is 1):
            self.b_low_obs[r] = value
        if(matrix is 2):
            self.b_high_obs[r] = value
        else:
            print("b MATRIX SET ERROR")
###SOIL CLASS SETUP###
class soil:
    def __init__(self, soilconfig):
        self.n = float(soilconfig['Bekker parameters']['n'])
        self.kc = float(soilconfig['Bekker parameters']['kc'])
        self.kphi = float(soilconfig['Bekker parameters']['kphi'])
        self.c = float(soilconfig['Bekker parameters']['c'])
        self.phi = float(soilconfig['Bekker parameters']['phi'])
        self.density = float(soilconfig['Misc']['density'])
        self.poisson = float(soilconfig['Misc']['poisson'])
        self.youngs_modulus = float(soilconfig['Misc']['youngs_modulus'])
###GEOMETRY CALCULAATORS###
def angle_calculation(rover, h):
    if rover.four_bar is False:
        alpha = math.asin((h- rover.wheel_radius)/rover.bogie_length)
        beta = (rover.wheel_link_length*math.cos(alpha) + 0.5*rover.bogie_length*math.sin(alpha) - rover.wheel_link_length)/(1.5*rover.bogie_length)
        return alpha, beta
###TERRAMECHANICS CALCULATIONS###
def compute_solid_wheel_contact_length(rover, soil, W):
    Ce = (1-math.pow(rover.poisson,2))/rover.youngs_modulus \
     + (1-math.pow(soil.poisson,2))/soil.youngs_modulus
    return 1.60*math.sqrt(W * 2 * rover.wheel_radius * Ce / rover.wheel_width)
def compute_contact_area(rover, soil, W):
    if rover.solid_wheel is True:
        l_con = compute_solid_wheel_contact_length(rover, soil, W)
        return l_con * rover.wheel_width
    else:
        print("ERROR: FLEXIBLE WHEEL MODULE NOT IMPLEMENTED")
        return 0
def compute_wheel_thrust(c, phi, Aw, W, slope_angle, J_K = 3):
    return (c*Aw + W*math.cos(slope_angle*math.pi/180.0)*math.tan(phi*math.pi/180.0))*(1.0-math.exp(-J_K))
def compute_compaction_resistance(b, kc, kphi, l,  z, n):
    if(b > l):
        return b*(kc/l + kphi)*math.pow(z,n+1)/(n+1)
    else:
        return b*(kc/b + kphi)*math.pow(z,n+1)/(n+1)
def compute_bulldozing_resistance(d, b, z, phi, c, W, rho, g):
    phi *= math.pi/180
    alpha = math.acos(1 - 2*z/d)
    sw = rho* g
    l_p = z*math.pow(math.tan(0.25*math.pi - phi/2),2)
    NC = W/(2*l_p*b*c)
    phi_n = math.atan(2.0*math.tan(phi)/3.0)
    kc = (NC - math.tan(phi_n))*math.pow(math.cos(phi_n),2)
    N_sw = W/(2 * b * sw)
    k_sw = (2*N_sw/math.tan(phi_n) + 1)*math.pow(math.cos(phi_n),2)
    return b*math.sin(alpha + phi)*(2*z*c*kc/1000 + sw*z*z*k_sw)/(2*math.sin(alpha)*math.cos(phi)) \
    + (math.pi*sw*math.pow(l_p,3)*(90 - phi*180/math.pi)/540 + math.pi*c*l_p*l_p/180 + c*l_p*l_p*math.tan(0.25*math.pi + phi/2))
def compute_gravitational_resistance(W, slope_angle):
    slope_angle*math.pi/180
    return W*math.sin(slope_angle)
def compute_rolling_resistance(W, fr):
    return fr*W
def compute_total_resistance(d, b, z, W, l, slope_angle, fr, c, n, phi, kc, kphi, rho, g):
    Rc = compute_compaction_resistance(b, kc, kphi, l, z, n)
    Rb = compute_bulldozing_resistance(d, b, z, phi, c, W, rho, g)
    Rg = compute_gravitational_resistance(W, slope_angle)
    Rf = compute_rolling_resistance(W, fr)
    return Rc + Rb + Rg + Rf
def compute_drawbar_pull(d, b, z, W, l, Aw, slope_angle, fr, c, n, phi, kc, kphi, rho, g, J_K = 3):
    H = compute_wheel_thrust(c, phi, Aw, W, slope_angle, J_K)
    R = compute_total_resistance(d, b, z, W, l, slope_angle, fr, c, n, phi, kc, kphi, rho, g)
    return H - R
###CALCULATION MATRIX SETUP
def mew_approximation(rover, soil):
    if rover.solid_wheel is True:
        W = rover.total_mass*g/3
        Aw = compute_contact_area(rover, soil, W)
        Te = compute_wheel_thrust(soil.c, soil.phi, Aw, W, 0)
        return Te/W
def setup_slope_matrix(rover, slope_angle):
    return 1
def setup_low_obs_matrix(rover, h):
    return 1
def setup_high_obs_matrix(rover,soil, h):
    mew = mew_approximation(rover, soil)
    alpha, beta = angle_calculation(rover, h)
    rover.A_set(2, 0, 0, 1)
    rover.A_set(2, 0, 1, -1)
    rover.A_set(2, 1, 2, -1)
    rover.A_set(2, 1, 3, 1)
    rover.A_set(2, 2, 3, rover.wheel_radius)
    rover.A_set(2, 2, 4, -1)
    rover.A_set(2, 3, 5, mew)
    rover.A_set(2, 3, 6, -1)
    rover.A_set(2, 4, 5, 1)
    rover.A_set(2, 4, 7, -1)
    rover.A_set(2, 5, 5, mew*rover.wheel_radius)
    rover.A_set(2, 5, 8, -1)
    rover.A_set(2, 6, 9, mew)
    rover.A_set(2, 6, 10, -1)
    rover.A_set(2, 7, 9, 1)
    rover.A_set(2, 7, 11, -1)
    rover.A_set(2, 8, 9, mew*rover.wheel_radius)
    rover.A_set(2, 8, 12, -1)
    rover.A_set(2, 9, 1, 1)
    rover.A_set(2, 9, 6, -1)
    rover.A_set(2, 9, 13, -1)
    rover.A_set(2, 10, 2, 1)
    rover.A_set(2, 10, 7, 1)
    rover.A_set(2, 10, 14, -1)
    rover.A_set(2, 11, 1, -0.5*rover.bogie_length*math.sin(alpha) + rover.wheel_link_length*math.cos(alpha))
    rover.A_set(2, 11, 2, 0.5*rover.bogie_length*math.cos(alpha) + rover.wheel_link_length*math.sin(alpha))
    rover.A_set(2, 11, 6, 0.5*rover.bogie_length*math.sin(alpha) + rover.wheel_link_length*math.cos(alpha))
    rover.A_set(2, 11, 7, -0.5*rover.bogie_length*math.cos(alpha) + rover.wheel_link_length*math.sin(alpha))
    rover.A_set(2, 12, 10, 1)
    rover.A_set(2, 12, 13, -1)
    rover.A_set(2, 13, 11, 1)
    rover.A_set(2, 13, 14, 1)
    rover.A_set(2, 14, 10, -1.5*rover.bogie_length*math.sin(beta) - rover.wheel_link_length*math.cos(beta))
    rover.A_set(2, 14, 11, 1.5*rover.bogie_length*math.cos(beta) - rover.wheel_link_length*math.sin(beta))
    rover.b_set(2, 1, rover.wheel_mass*g)
    rover.b_set(2, 4, rover.wheel_mass*g)
    rover.b_set(2, 7, rover.wheel_mass*g)
    rover.b_set(2, 10, rover.bogie_total_mass*g)
    rover.b_set(2, 13, rover.body_mass*g)
    rover.b_set(2, 14, rover.cg_length*math.cos(beta)*rover.body_mass*g)
###INI PARSING###
rovconfig = configparser.ConfigParser()
rovconfig.sections()
rovconfig.read('Roverdata.ini')
soilconfig = configparser.ConfigParser()
soilconfig.sections()
soilconfig.read('Soil.ini')
###MAIN BODY###
rover1 = rover(rovconfig, False, True)
mars_soil = soil(soilconfig)
setup_high_obs_matrix(rover1,mars_soil, 0.3)
#print(rover1.high_obs_matrix[13][14])
solution = np.linalg.solve(rover1.high_obs_matrix, rover1.b_high_obs)
